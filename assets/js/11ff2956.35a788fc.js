"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8134],{3064:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>o});var i=n(5893),a=n(1151),c=n(9705);const l={title:"Scripts",sidebar_position:30},r="Scripts",t={id:"guides/scripts",title:"Scripts",description:"Scala CLI accepts Scala scripts as files that end in .sc.",source:"@site/docs/guides/scripts.md",sourceDirName:"guides",slug:"/guides/scripts",permalink:"/docs/guides/scripts",draft:!1,unlisted:!1,editUrl:"https://github.com/Virtuslab/scala-cli/edit/main/website/docs/guides/scripts.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{title:"Scripts",sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"Migrating from the old Scala runner",permalink:"/docs/guides/old-runner-migration"},next:{title:"Shebang",permalink:"/docs/guides/shebang"}},d={},o=[{value:"Self executable Scala Script",id:"self-executable-scala-script",level:3},{value:"Arguments",id:"arguments",level:3},{value:"The name of script",id:"the-name-of-script",level:3},{value:"Define source files in using directives",id:"define-source-files-in-using-directives",level:3},{value:"Difference with Ammonite scripts",id:"difference-with-ammonite-scripts",level:3}];function h(e){const s={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"scripts",children:"Scripts"}),"\n",(0,i.jsxs)(s.p,{children:["Scala CLI accepts Scala scripts as files that end in ",(0,i.jsx)(s.code,{children:".sc"}),".\nUnlike ",(0,i.jsx)(s.code,{children:".scala"})," files, in scripts, any kind of statement is accepted at the top-level:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=hello.sc",children:'val message = "Hello from Scala script"\nprintln(message)\n'})}),"\n",(0,i.jsx)(s.p,{children:"A script is run with the Scala CLI command:"}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli hello.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Hello from Scala script\n"})})]}),"\n",(0,i.jsxs)(s.p,{children:["The way this works is that a script is wrapped in an ",(0,i.jsx)(s.code,{children:"object"})," before it's passed to the Scala compiler, and a ",(0,i.jsx)(s.code,{children:"main"}),"\nmethod is added to it.\nIn the previous example, when the ",(0,i.jsx)(s.code,{children:"hello.sc"})," script is passed to the compiler, the altered code looks like this:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",children:'object hello {\n  val message = "Hello from Scala script"\n  println(message)\n\n  def main(args: Array[String]): Unit = ()\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The name ",(0,i.jsx)(s.code,{children:"hello"})," comes from the file name, ",(0,i.jsx)(s.code,{children:"hello.sc"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"When a script is in a sub-directory, a package name is also inferred:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=my-app/constants/messages.sc",children:'def hello = "Hello from Scala scripts"\n'})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=my-app/main.sc",children:"import constants.messages\nprintln(messages.hello)\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Please note: when referring to code from another script, the actual relative path from the project root is used for the\npackage path. In the example above, as ",(0,i.jsx)(s.code,{children:"messages.sc"})," is located in the ",(0,i.jsx)(s.code,{children:"my-app/constants/"})," directory, to use the ",(0,i.jsx)(s.code,{children:"hello"}),"\nfunction you have to call ",(0,i.jsx)(s.code,{children:"constants.messages.hello"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["When referring to code from a piped script, just use its wrapper name: ",(0,i.jsx)(s.code,{children:"stdin"}),"."]}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"echo '@main def main() = println(stdin.message)' > PrintMessage.scala\necho 'def message: String = \"Hello\"' | scala-cli PrintMessage.scala _.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Hello\n"})})]}),"\n",(0,i.jsx)(s.p,{children:"To specify a main class when running a script, use this command:"}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli my-app --main-class main_sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Hello from Scala scripts\n"})})]}),"\n",(0,i.jsxs)(s.p,{children:["Both of the previous scripts (",(0,i.jsx)(s.code,{children:"hello.sc"})," and ",(0,i.jsx)(s.code,{children:"main.sc"}),") automatically get a main class, so this is required to\ndisambiguate them. If a main class coming from a regular ",(0,i.jsx)(s.code,{children:".scala"})," file is present in your app's context, that will be\nrun by default if the ",(0,i.jsx)(s.code,{children:"--main-class"})," param is not explicitly specified."]}),"\n",(0,i.jsxs)(s.p,{children:["When in doubt, you can always list the main classes present in your app by passing ",(0,i.jsx)(s.code,{children:"--list-main-classes"}),"."]}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"echo '@main def main1() = println(\"main1\")' > main1.scala\necho '@main def main2() = println(\"main2\")' > main2.scala\necho 'println(\"on-disk script\")' > script.sc\necho 'println(\"piped script\")' | scala-cli --list-main-classes _.sc main1.scala main2.scala script.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"stdin_sc script_sc main2 main1\n"})})]}),"\n",(0,i.jsx)(s.h3,{id:"self-executable-scala-script",children:"Self executable Scala Script"}),"\n",(0,i.jsxs)(s.p,{children:["You can define a file with the \u201cshebang\u201d header to be self-executable. Please remember to use ",(0,i.jsx)(s.code,{children:"scala-cli shebang"}),"\ncommand, which makes Scala CLI compatible with Unix shebang interpreter directive. For example, given this script:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=HelloScript.sc",children:'#!/usr/bin/env -S scala-cli shebang\nprintln("Hello world")\n'})}),"\n",(0,i.jsx)(s.p,{children:"You can make it executable and run it, just like any other shell script:"}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"chmod +x HelloScript.sc\n./HelloScript.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Hello world\n"})})]}),"\n",(0,i.jsx)(s.p,{children:"It is also possible to set Scala CLI command-line options in the shebang line, for example"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=Shebang213.sc",children:"#!/usr/bin/env -S scala-cli shebang --scala-version 2.13\n"})}),"\n",(0,i.jsxs)(s.p,{children:["The command ",(0,i.jsx)(s.code,{children:"shebang"})," also allows script files to be executed even if they have no file extension,\nprovided they start with the ",(0,i.jsxs)(s.a,{href:"/docs/guides/shebang#shebang-script-headers",children:[(0,i.jsx)(s.code,{children:"shebang"})," header"]}),".\nNote that those files are always run as scripts even though they may contain e.g. valid ",(0,i.jsx)(s.code,{children:".scala"})," program."]}),"\n",(0,i.jsx)(s.h3,{id:"arguments",children:"Arguments"}),"\n",(0,i.jsxs)(s.p,{children:["You may also pass arguments to your script, and they are referenced with the special ",(0,i.jsx)(s.code,{children:"args"})," variable:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=p.sc",children:"#!/usr/bin/env -S scala-cli shebang\n\nprintln(args(1))\n"})}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"chmod +x p.sc\n./p.sc hello world\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"world\n"})})]}),"\n",(0,i.jsx)(s.h3,{id:"the-name-of-script",children:"The name of script"}),"\n",(0,i.jsxs)(s.p,{children:["You can access the name of the running script inside the script itself using the special ",(0,i.jsx)(s.code,{children:"scriptPath"})," variable:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=script.sc",children:"#!/usr/bin/env -S scala-cli shebang\n\nprintln(scriptPath)\n"})}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"chmod +x script.sc\n./script.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"./script.sc\n"})})]}),"\n",(0,i.jsx)(s.h3,{id:"define-source-files-in-using-directives",children:"Define source files in using directives"}),"\n",(0,i.jsxs)(s.p,{children:["You can also add source files with the using directive ",(0,i.jsx)(s.code,{children:"//> using file"})," in Scala scripts:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=main.sc",children:"//> using file Utils.scala\n\nprintln(Utils.message)\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-scala",metastring:"title=Utils.scala",children:'object Utils {\n  val message = "Hello World"\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:["Scala CLI takes into account and compiles ",(0,i.jsx)(s.code,{children:"Utils.scala"}),"."]}),"\n",(0,i.jsxs)(c.v,{children:[(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scala-cli main.sc\n"})}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-text",children:"Hello World\n"})})]}),"\n",(0,i.jsx)(s.h3,{id:"difference-with-ammonite-scripts",children:"Difference with Ammonite scripts"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"http://ammonite.io",children:"Ammonite"})," is a popular REPL for Scala that can also compile and run ",(0,i.jsx)(s.code,{children:".sc"})," files."]}),"\n",(0,i.jsx)(s.p,{children:"Scala CLI and Ammonite are similar, but differ significantly when your code is split in multiple scripts:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["In Ammonite, a script needs to use ",(0,i.jsx)(s.code,{children:"import $file"})," directives to use values defined in another script"]}),"\n",(0,i.jsx)(s.li,{children:"With Scala CLI, all scripts passed can reference each other without such directives"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"On the other hand:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:['You can pass a single "entry point" script as input to Ammonite, and Ammonite finds the scripts it depends on via\nthe ',(0,i.jsx)(s.code,{children:"import $file"})," directives"]}),"\n",(0,i.jsx)(s.li,{children:"Scala CLI requires all scripts to be passed beforehand, either one-by-one, or by putting them in a directory, and\npassing the directory to Scala CLI"}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,a.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},9705:(e,s,n)=>{n.d(s,{m:()=>l,v:()=>c});n(7294);var i=n(2004),a=n(5893);function c(e){let{children:s}=e;return(0,a.jsx)("div",{className:"runnable-command",children:s})}function l(e){let{url:s}=e;return(0,a.jsx)(i.Z,{playing:!0,loop:!0,muted:!0,controls:!0,width:"100%",height:"",url:s})}}}]);